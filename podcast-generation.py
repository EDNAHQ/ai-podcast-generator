import requests
import os
import time
from dotenv import load_dotenv

load_dotenv()

# Set up headers with your API secrety key and user ID
user_id = os.getenv("PLAY_AI_USER_ID")
secret_key = os.getenv("PLAY_AI_SECRET_KEY")

headers = {
    'X-USER-ID': user_id,
    'Authorization': secret_key,
    'Content-Type': 'application/json',
}

# define the model
model = 'PlayDialog'

# define voices for the 2 hosts
# find all voices here https://docs.play.ai/tts-api-reference/voices
voice_1 = 's3://voice-cloning-zero-shot/c14e50f2-c5e3-47d1-8c45-fa4b67803d19/original/manifest.json'
voice_2 = 's3://voice-cloning-zero-shot/50381567-ff7b-46d2-bfdc-a9584a85e08d/original/manifest.json'

# podcast transcript should be in the format of Host 1: ... Host 2:
transcript = """
Host 1: Have you seen the latest workflow Sam's been using for his web applications?

Host 2: Yeah, it's pretty cutting-edge. He mentioned using a tool called Lovable, which used to be GPT Engineer, right?

Host 1: Exactly. Lovable is a game-changer for front-end development. It allows you to build applications quickly using natural language prompts. Sam was able to mock up an entire front-end for his project, Prompt Central for Enterprise DNA, just by describing what he wanted.

Host 2: That's impressive. So instead of writing all the code manually, Lovable generates it for you and even creates a GitHub repository automatically?

Host 1: Yes, and that's a huge time-saver. It not only writes the code but organizes it into best practice components. You can then push this code to GitHub, which makes collaboration and version control so much easier.

Host 2: Speaking of GitHub, Sam mentioned he's become much more familiar with it recently. How's he integrating it into his workflow?

Host 1: He's using GitHub as the central hub for managing his code. With Lovable handling the initial code generation, he can focus on building and iterating without getting bogged down by the basics of pushing to GitHub or managing repositories.

Host 2: That makes sense. Automating those repetitive tasks must save a lot of time. And Sam also talked about using voice commands more in his development process. How's that working out for him?

Host 1: It's been a huge boost for his productivity. By using voice to interact with these tools, he's able to work more efficiently, especially when dealing with repetitive tasks. It feels more natural and less cumbersome compared to typing everything out.

Host 2: That's really innovative. Combining voice commands with tools like Lovable and GitHub must really streamline the entire development process. Did he mention any specific projects he's working on with this setup?

Host 1: Yes, his current project is Prompt Central for Enterprise DNA. He used Lovable to create the front page, internal pages, and a lot of the functionality just through simple prompts. Then he supplemented it with a backend built in Supabase. It’s all about speeding up the development workflow and making it easier to mock up ideas before handing them off to developers.

Host 2: Supabase for the backend, got it. That combination sounds powerful. How does he handle the integration between the front-end generated by Lovable and the backend services?

Host 1: He’s leveraging GitHub to manage the codebase, which allows him to integrate additional functionality from open-source projects seamlessly. This setup not only accelerates development but also maintains a high standard of code quality by organizing everything into components and following GitHub best practices.

Host 2: That's smart. Using GitHub to handle the integration ensures that everything stays organized and manageable as the project scales. Did he mention any challenges he faced while setting up this workflow?

Host 1: One of the main challenges was getting comfortable with GitHub itself. Sam wasn’t very familiar with it initially, but using tools like Lovable that integrate directly with GitHub helped him learn the ins and outs quickly. Now, he’s much more comfortable managing repositories, creating branches, and collaborating within GitHub.

Host 2: It's great to hear that these tools not only enhance productivity but also help in learning and adapting to essential platforms like GitHub. Any other tools he highlighted that are part of his workflow?

Host 1: Yes, he also mentioned using Cascade, a new tool that provides better context for your entire application. Unlike other tools that only look at a few files at a time, Cascade can understand the broader scope of your project, making more informed recommendations and managing the console more effectively.

Host 2: Cascade sounds like it addresses some of the limitations of traditional development tools by providing a more holistic view of the project. How does it improve the experience compared to other tools?

Host 1: For one, Cascade can manipulate the console and run applications without you having to manually enter commands. This reduces the complexity and potential for errors, especially for those who find the command line intimidating. It also integrates seamlessly with GitHub, allowing you to push updates without needing to use GitHub Desktop or other separate tools.

Host 2: That's a significant improvement. Automating those command-line interactions can make development much more accessible and less error-prone. Plus, having everything integrated within one tool simplifies the workflow even further.

Host 1: Exactly. And Sam pointed out that Cascade uses advanced models like Claude 3.5, which provide superior context understanding. This means it can handle more files and offer better recommendations across the entire app, not just isolated parts.

Host 2: With such powerful tools, it's no wonder Sam is so enthusiastic about this new workflow. It really seems to open up a lot of possibilities for faster and more efficient app development.

Host 1: Definitely. The combination of Lovable for front-end development, GitHub for version control and collaboration, and Cascade for enhanced context and automation is creating a seamless and highly productive environment for developers.

Host 2: It's inspiring to see how these tools are democratizing app development, making it easier for more people to create and innovate without getting stuck on the technical details. I'm excited to see how this workflow evolves and what projects come out of it.

Host 1: Same here. It's an exciting time to be in development, and workflows like Sam's are leading the way in showing what's possible with these new tools.

Host 2: Moving on, Sam also emphasized the importance of Data Mentor in his development process. Have you explored how he's integrating that?

Host 1: Yes, Data Mentor seems to be a crucial part of his setup. From what Sam shared, it's all about using AI to understand and manage code more effectively within GitHub. He’s been using it to get detailed explanations of specific code snippets and to create comprehensive threads about his projects.

Host 2: That’s incredibly useful. It not only speeds up the learning process but also ensures that his codebase remains clean and well-understood. Plus, creating threads with detailed explanations helps in maintaining a clear record of the development process, which is great for collaboration and future reference.

Host 1: Right. And Sam also highlighted the use of advanced AI models like Claude 3.5 within Cascade. These models provide a deeper understanding of the entire application’s context, which means better recommendations and more accurate error handling. It’s like having an intelligent assistant that not only follows commands but also understands the bigger picture of what you’re building.

Host 2: That level of context awareness must make a huge difference in managing complex projects. By understanding how different components interact, Cascade can offer more relevant suggestions and automate tasks more effectively. Did Sam mention any specific scenarios where Cascade really shined?

Host 1: Yes, he did. One example was how Cascade handles the console. Traditionally, managing the command line can be daunting, but Cascade automates those interactions. It runs applications, manages dependencies, and even catches errors without Sam having to manually input commands. This reduces the learning curve and minimizes the chances of mistakes, especially for those who aren’t as comfortable with the terminal.

Host 2: That’s a significant improvement. Automating command-line tasks not only makes development more accessible but also frees up time for more creative and strategic work. And integrating this with GitHub means that all changes and updates are handled smoothly, maintaining a well-organized and up-to-date codebase.

Host 1: Absolutely. Sam also touched on using Windows Surf as his recommended IDE. It’s a newer tool, but he found it to be exceptionally effective. With features like Cascade integration and advanced AI support, Windows Surf seems to provide a seamless development environment that enhances productivity and code quality.

Host 2: I checked out Windows Surf, and it does seem promising. The integration with AI tools and the ability to manage workflows within the IDE itself can significantly streamline the development process. It’s great to see how Sam is leveraging these tools to create a highly efficient and organized workflow.

Host 1: Definitely. Another key aspect of Sam's workflow is the use of natural language prompting to write thousands of lines of code. By speaking to his computer instead of typing, he’s able to build and iterate on his projects much faster. This approach not only boosts productivity but also makes the development process feel more intuitive and less laborious.

Host 2: That’s a game-changer. Using voice commands to generate code can make the process more accessible, especially for those who might find typing tedious or are multitasking. It’s impressive how Sam is combining these advanced tools to create a workflow that’s both efficient and user-friendly.

Host 1: And the best part is, this workflow is highly adaptable. Whether you’re working on front-end development with Lovable, managing your codebase with GitHub, leveraging AI with Data Mentor and Cascade, or using an advanced IDE like Windows Surf, each tool complements the others to create a cohesive and powerful development environment.

Host 2: It really showcases the potential of modern development tools to transform how we build applications. By integrating these technologies, developers can focus more on creativity and problem-solving, while automation handles the repetitive and technical aspects.

Host 1: Exactly. Sam’s workflow is a perfect example of how embracing these tools can lead to significant productivity gains and higher-quality projects. It’s inspiring to see how these innovations are making app development more accessible and efficient for everyone.

Host 2: Absolutely. For anyone looking to enhance their development process, taking a page from Sam’s workflow and integrating these advanced tools can open up new possibilities and streamline your projects in ways you might not have imagined.

Host 1: So, to sum it up, Sam’s approach combines cutting-edge tools like Lovable, GitHub, Data Mentor, Cascade, and Windows Surf to create a seamless and highly productive workflow. It’s all about leveraging the latest technologies to make development faster, easier, and more intuitive.

Host 2: And with the continuous evolution of these tools, there’s always something new to explore and integrate, ensuring that developers can keep improving their workflows and staying ahead of the curve.

Host 1: It’s an exciting time to be in development, and workflows like Sam’s are leading the way in demonstrating what’s possible with the latest tools and technologies.

Host 2: Definitely inspiring. It’s amazing to see how these tools are lowering the barriers to entry and empowering more people to create and innovate.

Host 1: Absolutely. Whether you’re a seasoned developer or just starting out, integrating these advanced tools into your workflow can make a huge difference in how you approach projects and solve problems.

Host 2: So, if you’re looking to take your development process to the next level, consider exploring tools like Lovable, Cascade, and Windows Surf. They can transform the way you build applications and manage your code.

Host 1: And don’t forget the importance of platforms like GitHub and AI-driven tools like Data Mentor. They’re essential for collaboration, learning, and maintaining high-quality codebases.

Host 2: It’s all about finding the right combination of tools that fit your workflow and help you achieve your goals more efficiently.

Host 1: Exactly. Sam’s workflow is a testament to how powerful these integrations can be. It’s inspiring to see what’s possible when you leverage the latest technologies effectively.

Host 2: Absolutely. It’s an exciting time to be a developer, and there’s so much potential to innovate and create amazing things with these tools at our disposal.

Host 1: So, here’s to embracing new technologies and pushing the boundaries of what we can achieve in web application development!

Host 2: Cheers to that!
"""


payload = {
    'model': model,
    'text': transcript,
    'voice': voice_1,
    'voice2': voice_2,
    'turnPrefix': 'Host 1:',
    'turnPrefix2': 'Host 2:',
    'outputFormat': 'mp3',
}

# Add feedback when starting
print("Starting podcast generation...")

# Show what we're sending to the API
print(f"Sending transcript with length: {len(transcript)} characters")
response = requests.post('https://api.play.ai/api/v1/tts/', headers=headers, json=payload)

# Show the initial response
print(f"Initial response status code: {response.status_code}")
print(f"Response body: {response.json()}")

job_id = response.json().get('id')
print(f"Got job ID: {job_id}")

url = f'https://api.play.ai/api/v1/tts/{job_id}'
print(f"Polling URL: {url}")
print("\nChecking status every 2 seconds...")

# Add a counter to see how long it's taking
attempt = 1
delay_seconds = 2
while True:
    response = requests.get(url, headers=headers)
    
    if response.ok:
        status = response.json().get('output', {}).get('status')
        print(f"Attempt {attempt}: Status is {status}")
        if status == 'COMPLETED':
            podcast_audio = response.json().get('output', {}).get('url')
            break
    else:
        print(f"Attempt {attempt}: Got error response: {response.status_code}")
    
    attempt += 1
    time.sleep(delay_seconds)

print("\nPodcast generation completed!")
print(f"Audio URL: {podcast_audio}")

print(f"Using User ID: {user_id}")
print(f"Secret key present: {'Yes' if secret_key else 'No'}")
